// Cyril Kamal - Dec 2021
//
// This file contains the RESTful API functionality necessary to send and receive HTML messages.


#include "NetworkingFunctions.h"
#include "RESTfulAPI.h"
#include <stdio.h>
#include <stdbool.h>


// This function sends a formatted request for ALL POSTS
void GETposts(SOCKET peer_socket)
{
	const char* message =
		"GET /posts HTTP/1.1\r\n"
		"content-type: application/json\r\n"
		"accept-encoding: gzip, defalte\r\n"
		"Connection: close\r\n\0\0";

	int sent = send(peer_socket, message, strlen(message), 0);
	if (sent == 0)
	{
		fprintf(stderr, "send failed\n");
		exit(1);
	}
}


// This function parses and neatly outputs the response from the server generated by GETposts()
void processGETpostsResponse(char* serverResponse)
{
	char* message = strstr(serverResponse, "\n\n"); // find the message content after the http header information (the responses separate the header from the content with two newlines)
	message = message + 2;
	if (message != NULL)
	{
		char* token;
		token = strtok(message, "\n");
		printf("\n~~~~ ALL POSTS ~~~~\n");
		while (token != NULL) // neatly print the posts by parsing the string returned by the server
		{
			printf("Post ID: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Author: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Topic: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Posting: %s\n\n", token);
			token = strtok(NULL, "\n");
		}
	}
		
}


// This function sends a formatted request for a specific post (described by the postID)
void GETpost(SOCKET peer_socket, int postID)
{
	char message[MAXBUFFER];
	memset(message, '\0', MAXBUFFER);

	sprintf(message, "GET /posts/%d HTTP/1.1", postID);

	const char* header =
		"content-type: application/json\r\n"
		"accept-encoding: gzip, defalte\r\n"
		"Connection: close\r\n";

	sprintf(message, "%s\r\n%s\n\0\0", message, header); // form the entire message as one package

	int sent = send(peer_socket, message, strlen(message), 0);
	if (sent == 0)
	{
		fprintf(stderr, "send failed\n");
		exit(1);
	}
}


// This function parses and neatly outputs the response from the server generated by GETpost()
void processGETpostResponse(char* serverResponse)
{
	char* message = strstr(serverResponse, "\n\n"); // find the message content after the http header information
	message = message + 2;
	if (message != NULL)
	{
		char* token;
		token = strtok(message, "\n");
		printf("\n~~~~ QUERY RESULTS ~~~~\n");
		while (token != NULL) // neatly print the post by parsing the string returned by the server
		{
			printf("Post ID: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Author: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Topic: %s\n", token);
			token = strtok(NULL, "\n");
			printf("Posting: %s\n\n", token);
			token = strtok(NULL, "\n");
		}
	}
}


// This function sends a formatted request to the server to replace the data of a post with new data
void PUT(SOCKET peer_socket, int postID, char* author, char* topic, char* posting)
{
	char message[MAXBUFFER];
	memset(message, '\0', MAXBUFFER);

	sprintf(message, "PUT /posts/%d HTTP/1.1", postID); // specify which post this update is for

	const char* header =
		"content-type: application/json\r\n"
		"accept-encoding: gzip, defalte\r\n"
		"Connection: close\r\n";

	sprintf(message, "%s\r\n%s\n%s\n%s\n%s\n\0\0", message, header, author, topic, posting); // formulate whole message

	int sent = send(peer_socket, message, strlen(message), 0);
	if (sent == 0)
	{
		fprintf(stderr, "send failed\n");
		exit(1);
	}
}


// This function sends a formatted request to create a new post in the database and fill it with new data
void POST(SOCKET peer_socket, char* author, char* topic, char* posting)
{
	char message[MAXBUFFER];
	memset(message, '\0', MAXBUFFER);

	const char* header =
		"POST /posts HTTP/1.1\r\n"
		"content-type: application/json\r\n"
		"accept-encoding: gzip, defalte\r\n"
		"Connection: close\r\n";

	sprintf(message, "%s\n%s\n%s\n%s\n\0\0", header, author, topic, posting); // form whole message as one

	int sent = send(peer_socket, message, strlen(message), 0);
	if (sent == 0)
	{
		fprintf(stderr, "send failed\n");
		exit(1);
	}
	return;
}


// This function sends a formatted request to delete a post presently inside the database.
void DELETE_POST(SOCKET peer_socket, int postID)
{
	char message[MAXBUFFER];
	memset(message, '\0', MAXBUFFER);

	sprintf(message, "DELETE /posts/%d HTTP/1.1", postID); //append the post num

	const char* header =
		"content-type: application/json\r\n"
		"accept-encoding: gzip, defalte\r\n"
		"Connection: close\r\n";

	sprintf(message, "%s\r\n%s\n\0\0", message, header); // formulate whole message as one

	int sent = send(peer_socket, message, strlen(message), 0);
	if (sent == 0)
	{
		fprintf(stderr, "send failed\n");
		exit(1);
	}
}


// This function waits and captures the server's response
char* receiveMessage(SOCKET peer_socket)
{
	char buffer[MAXBUFFER];
	memset(buffer, '\0', MAXBUFFER);

	while (recv(peer_socket, buffer, MAXBUFFER, 0) == 0);
	return buffer;
}


// This function peeks into a server response to check the HTML response code (500 is error)
bool IsRequestSuccessful(char* serverResponse)
{
	if (strstr(serverResponse, "HTTP/1.1 500") != NULL)
	{
		printf("\nServer Error 500: Request not fulfilled\n");
		return false;
	}
	else
	{
		return true;
	}
}


